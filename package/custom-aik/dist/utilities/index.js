import{mkdirSync as S,readFileSync as C,writeFileSync as v}from"node:fs";import{dirname as T,relative as D}from"node:path";import{fileURLToPath as f}from"node:url";import{parse as V,prettyPrint as F}from"recast";import $ from"recast/parsers/typescript.js";var E=({srcDir:t,logger:r,specifier:e})=>{let n=f(new URL("env.d.ts",t));e instanceof URL&&(e=f(e),e=D(f(t),e),e=e.replaceAll("\\","/"));let a=C(n,"utf8");if(a.includes(`/// <reference types='${e}' />`)||a.includes(`/// <reference types="${e}" />`))return;let o=a.replace("/// <reference types='astro/client' />",`/// <reference types='astro/client' />
/// <reference types='${e}' />`).replace('/// <reference types="astro/client" />',`/// <reference types="astro/client" />
/// <reference types="${e}" />`);o!==a&&(v(n,o),r.info("Updated env.d.ts types"))},O=({name:t,content:r,root:e,srcDir:n,logger:a})=>{let o=new URL(`.astro/${t}.d.ts`,e),i=f(o);E({srcDir:n,logger:a,specifier:o}),S(T(i),{recursive:!0}),v(i,F(V(r,{parser:$}),{tabWidth:4}).code,"utf-8")};import{AstroError as h}from"astro/errors";function g(t){let r=[];if(t){for(let e of t)if(e){if(Array.isArray(e)){r.push(...g(e));continue}e instanceof Promise||r.push(e.name)}}return r}var c=({plugin:t,config:r})=>{if(!t||t instanceof Promise)return!1;let e=new Set(g(r?.vite?.plugins)),n=new Set;if(typeof t=="string"&&n.add(t),typeof t=="object")if(Array.isArray(t)){let a=new Set(g(t));for(let o of a)n.add(o)}else n.add(t.name);return[...n].some(a=>e.has(a))};var d=({warnDuplicated:t=!0,plugin:r,config:e,logger:n,updateConfig:a})=>{t&&e&&n&&c({plugin:r,config:e})&&n.warn(`The Vite plugin "${r.name}" is already present in your Vite configuration, this plugin may not behave correctly.`),a({vite:{plugins:[r]}})};var j=t=>{let r=1;return`${t.replace(/-(\d+)$/,(e,n)=>(r=parseInt(n)+1,""))}-${r}`},k=t=>`\0${t}`,L=(t,r)=>{let e=Array.isArray(r)?r:Object.entries(r).map(([o,i])=>({id:o,content:i,context:void 0})),n={};for(let{id:o,context:i}of e)n[o]??=[],n[o]?.push(...i===void 0?["server","client"]:[i]);for(let[o,i]of Object.entries(n))if(i.length!==[...new Set(i)].length)throw new h(`Virtual import with id "${o}" has been registered several times with conflicting contexts.`);let a=Object.fromEntries(e.map(({id:o})=>{if(o.startsWith("astro:"))throw new h(`Virtual import name prefix can't be "astro:" (for "${o}") because it's reserved for Astro core.`);return[k(o),o]}));return{name:t,resolveId(o){if(e.find(i=>i.id===o))return k(o)},load(o,i){let s=a[o];if(s){let l=i?.ssr?"server":"client",m=e.find(p=>p.id===s&&p.context===void 0?!0:p.context===l);if(m)return m.content}}}},P=({name:t,imports:r,config:e,updateConfig:n})=>{let a=`vite-plugin-${t}`;for(;c({plugin:a,config:e});)a=j(a);d({warnDuplicated:!1,plugin:L(a,r),updateConfig:n})};import{AstroError as A}from"astro/errors";var y=({name:t,position:r,relativeTo:e,config:n})=>{let a=n.integrations.findIndex(i=>i.name===t);if(a===-1)return!1;if(r===void 0)return!0;if(e===void 0)throw new A("Cannot perform a relative integration check without a relative reference.","Pass `relativeTo` on your call to `hasIntegration` or remove the `position` option.");let o=n.integrations.findIndex(i=>i.name===e);if(o===-1)throw new A("Cannot check relative position against an absent integration.");return r==="before"?a<o:a>o};var U=({command:t,injectRoute:r,injectedRoute:e})=>{t==="dev"&&r(e)};import{readdirSync as N,statSync as M}from"node:fs";import{join as _,relative as W,resolve as B}from"pathe";var I=(t,r=t)=>{let e=N(t),n=[];for(let a of e){let o=_(t,a);if(M(o).isDirectory()){let s=I(o,r);n=n.concat(s)}else{let s=W(r,o);n.push(s)}}return n},q=({addWatchFile:t,command:r,dir:e,updateConfig:n})=>{if(r!=="dev")return;let a=I(e).map(o=>B(e,o));for(let o of a)t(o);n({vite:{plugins:[{name:"rollup-plugin-astro-tailwind-config-viewer",buildStart(){for(let o of a)this.addWatchFile(o)}}]}})};import{readFileSync as J}from"node:fs";import"astro";import{fileURLToPath as Y}from"node:url";import{dirname as z,resolve as G}from"pathe";var w=t=>{let r=t;return r.startsWith("file://")&&(r=z(Y(r))),{resolve:(...e)=>G(r,...e)}};var K=({id:t,name:r,icon:e,framework:n,src:a,style:o,config:i,addDevToolbarApp:s,updateConfig:l,injectScript:m})=>{let p=`virtual:astro-devtoolbar-app-${t}`,{resolve:x}=w(import.meta.url),u=J(x(`../stubs/add-devtoolbar-framework-app/${n}.js`),"utf-8"),b=e.replace("`",'${"`"}');u=u.replace("@@COMPONENT_SRC@@",a).replace("@@ID@@",t).replace("@@NAME@@",r).replace("@@ICON@@",b).replace("@@STYLE@@",o??""),P({name:t,imports:{[p]:u},config:i,updateConfig:l}),n==="react"&&import("@vitejs/plugin-react").then(H=>{let R=H.default.preambleCode.replace("__BASE__","/");m("page",R)}),s(p)};import"astro";var Q=({integration:t,options:r,updateConfig:e,config:n,logger:a})=>{if(r?.ensureUnique&&y({name:t.name,config:n})){a.warn(`Integration "${t.name}" has already been added by the user or another integration. Skipping.`);return}e({integrations:[t]})};export{K as addDevToolbarFrameworkApp,O as addDts,Q as addIntegration,P as addVirtualImports,d as addVitePlugin,y as hasIntegration,c as hasVitePlugin,U as injectDevRoute,q as watchIntegration};
//# sourceMappingURL=index.js.map